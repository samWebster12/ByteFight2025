game.game_map
class Map:
Map is an internal utility class used by board to initialize constants and store immutable map data for the board.

Map(map_string)
decay_timeline
trap_timeout
map_string
infos
dim_x
dim_y
start_a
start_b
start_size
min_player_size
is_record
cells_walls
max_turns
portal_dict
cells_portals
def add_apple_spawns(self, apples_possible, num_apples, apples, turn_num, symmetry):
Algorithm for determining random apple spawns in O(N*T) grid spaces, Where N is the number of possible spaces and T is the number of grid spaces.

def get_recorded_map(self):
Replaces random apple spawns in the given string with generated spawns.

def reflect(self, coords, symmetry):
Reflects coordinates across the map given a type of symmetry.

game.game_queue
class Queue:
This class implements a byte queue implemented using a circular array, optimized by numpy vectorization. Note that self.head and self.tail point to valid values. Thus, the queue runs on the interval [self.head, self.tail] inclusive. Adding and removing elements is done without emptiness checking: the queue's tail and head wil always increment on push or pop. When the queue is initialized or reinitialized via resizing, the tail is set to self.size-1 instead to conform to this protocol, potentially causing the tail to be negative during part of the calculation.

Queue(dim: int = 2, init_capacity: int = 50, copy: bool = False)
Initializes the queue with specified dimensions and capacity.

Parameters:
dim (int, optional): The dimension of the queue. Defaults to 2.
init_capacity (int, optional): The initial capacity of the queue. Defaults to 50.
copy (bool, optional): Whether the queue is initializing as a copy.

capacity
dim
def get_copy(self) -> Queue:
Returns:
Queue: A deep copy of the current queue.

def push(self, move: numpy.ndarray):
Enqueues a value at the tail of the queue.

Parameters:
move (numpy.ndarray): The value to enqueue.

def peek_head(self) -> numpy.ndarray:
Retrieves the value at the head of the queue without removing it.

Returns:
np.array: The value at the head of the queue.

def peek_tail(self) -> numpy.ndarray:
Retrieves the value at the tail of the queue without removing it.

Returns:
np.array: The value at the tail of the queue.

def peek_all(self) -> numpy.ndarray:
Retrieves all values in the queue without removing them.

Returns:
numpy.ndarray: A numpy array containing all values in the queue.

def peek_many_tail(self, num_moves: int) -> numpy.ndarray:
Retrieves num_moves values starting from the tail and progressing toward the head, without removing them. Returns values in order starting with closest to head.

Parameters: num_moves (int): The number of values to retrieve from the tail toward the head.

Returns:
numpy.ndarray: A NumPy array containing the values starting from the tail and progressing toward the head.

def peek_many_head(self, num_moves: int) -> numpy.ndarray:
Retrieves num_moves values starting from the head and progressing toward the tail, without removing them.

Parameters:
num_moves (int): The number of values to retrieve from the head toward the tail.

Returns:
numpy.ndarray: A NumPy array containing the values starting from the head and progressing toward the tail.

def push_many(self, moves: numpy.ndarray):
Enqueues multiple values at the tail of the queue.

Parameters:
moves (numpy.ndarray): The values to enqueue.

def pop(self) -> numpy.ndarray:
Removes and returns a value at the head of the queue.

Returns:
numpy.ndarray: The value removed from the head of the queue.

def pop_many(self, num_moves: int) -> numpy.ndarray:
Removes and returns multiple values from the head of the queue.

Parameters:
num_moves (int): The number of values to remove from the head of the queue.

Returns:
numpy.ndarray: An array containing the values removed from the head of the queue.

def is_empty(self) -> bool:
Returns whether the queue is empty.

Returns:
bool: True if the queue is empty, False otherwise.

game.board
class Board:
Board is the game engine's representation of the current match.

Any coordinates should be given to the board in the form of x, y. Game objects are displayed, indexed, and stored on the board arrays as y, x for geometrical accuracy.

Check_validity is on by default for most functions, but slows down execution. If a player is confident their actions are valid, they can directly apply turns and moves with check_validity as false.

Be wary that invalid actions/turns could lead to functions throwing errors, so make sure to handle them with a try/except in case so that your program doesn't crash. If an apply function throws an error, it is not guarenteed that the board state will be valid or that the state will be the same as when the function started.

Board(
	game_map: game.game_map.Map,
	time_to_play: float = 20,
	build_history: bool = False,
	copy: bool = False
)
Initializes the board with the specified game map and configuration options.

Parameters:
game_map (game_map.Map): The map representing the game environment.
time_to_play (float, optional): The time limit for the game in seconds. Defaults to 65536.
build_history (bool, optional): Whether to track the history of the game. Defaults to False.
copy (bool, optional): Whether to initialize a copy of the game map. Defaults to False.

map
def is_as_turn(self) -> bool:
Returns:
bool: If it is player a's turn to play.

def get_a_time(self) -> float:
Returns:
float: Time in seconds that player a has to make a turn.

def get_b_time(self) -> float:
Returns:
float: Time in seconds that player b has to make a turn.

def has_apple_tuple(self, loc: tuple) -> bool:
Returns whether there is an apple at the provided location. The location should be in the form (x, y).

Parameters:
loc (tuple): The coordinates (x, y) of the location to check for an apple.

Returns:
bool: True if there is an apple at the specified location, False otherwise.

def has_apple(self, x: int, y: int) -> bool:
Returns whether there is an apple at the given coordinates (x, y).

Parameters:
x (int): The x-coordinate to check for an apple.
y (int): The y-coordinate to check for an apple.

Returns:
bool: True if there is an apple at the given coordinates, False otherwise.

def tiebreak(self):
Tiebreaks the game. Tiebreak occurs first by apples eaten, then by ending length of snake. If both are equal result is a tie.

def set_build_history(self, build_history: bool):
Sets whether the history of the game should be recorded.

Parameters:
build_history (bool): Whether to track the game history. True to record, False to not record.

def set_winner(self, result: game.enums.Result, reason: str = 'invalid'):
Sets the winner and the reason for the game's outcome.

Parameters:
result (enums.Result): The winner of the game. reason (str, optional): The reason for the outcome. Defaults to "invalid".

def get_winner(self) -> game.enums.Result:
Returns the winner of the game.

Returns:
enums.Result: The winner of the game.

def get_win_reason(self) -> str:
Returns the string explaining the reason why the game was won.

Returns:
str: The reason for the game's outcome.

def get_history_json(self):
Encodes the entire history of the game in a format readable by the renderer.

def is_valid_bid(self, bid: int) -> bool:
Returns whether a given starting bid is valid.

Parameters:
bid (int): The starting bid to check.

Returns:
bool: True if the bid is valid, False otherwise.

def resolve_bid(self, bidA: int, bidB: int):
Resolves the bid between two players. The player with the higher bid gets to go first. If the bids are equal, the starting player is determined by a coin toss.

Parameters:
bidA (int): The bid from player A.
bidB (int): The bid from player B.

def get_bid_resolved(self) -> bool:
Returns whether the bid for the first turn has been resolved.

Returns:
bool: True if the bid has been resolved, False otherwise.

def is_valid_trap(self, a_to_play: bool = None) -> bool:
Returns whether the current player can deploy a trap.

Parameters:
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.

Returns:
bool: True if the current player can apply a trap, False otherwise.

def is_valid_action(self, action: game.enums.Action, a_to_play: bool = None) -> bool:
Returns whether the given action is valid for the current player.

If the action is a trap, it checks if the trap is valid for the current player. Otherwise, it checks if the move is valid.

Parameters:
action (enums.Action): The action to validate.
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.

Returns:
bool: True if the action is valid, False otherwise.

def is_valid_move(
	self,
	move: game.enums.Action,
	sacrifice: int = None,
	a_to_play: bool = None
) -> bool:
Returns whether the given move is valid for the current player. Does not check for decay.

If a sacrifice is applied, it checks if the move is still valid given the sacrifice.

Parameters:
move (enums.Action): The move to validate.
sacrifice (int, optional): The amount of sacrifice to apply. If not provided, the current sacrifice value is used.
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.

Returns:
bool: True if the move is valid, False otherwise.

def is_valid_turn(self, turn, a_to_play: bool = None) -> bool:
Returns if the given turn is a valid turn. A turn can be an Action or iterable of Actions. Actions can either be in the form of enums given in game.enums.Action or the ints to which the Action enum is mapped.

Parameters:
turn (enums.Action or Iterable[enums.Actions] or Iterable[int]): The action(s) the player takes in sequence.
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.

Returns:
bool: True if the turn is valid, False otherwise.

def is_valid_cell(self, loc: tuple | numpy.ndarray) -> bool:
Checks if the cell is in bounds of the board, then if it is available to be moved into.

Parameters:
loc (tuple or numpy.ndarray): The coordinates of the cell to check, in the form (x, y).

Returns:
bool: True if the cell is valid (in bounds and available), False otherwise.

def is_valid_cell_copy(self, loc, cells_player_copy, cells_enemy):
Checks if the cell is in bounds of the board, then if it is available to be moved into using a copy of the player board (in case player snake needs to be mutated). For internal usage by board class.

def cell_in_bounds(self, loc: tuple | numpy.ndarray) -> bool:
Checks if a cell is within map bounds.

Parameters:
loc (Union[tuple, np.ndarray]): The coordinates of the cell to check, either as a tuple (x, y) or a numpy array.

Returns:
bool: True if the cell is within the map bounds, False otherwise.

def apply_decay(self, a_to_play: bool = None, check_validity: bool = True) -> bool:
Applies a round of decay.

Parameters:
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.
check_validity (bool, optional): Whether to check the validity of the decay action. Defaults to True.

Returns:
bool: True if the decay was applied successfully, False if the trap is invalid.

def increment_decay(self):
Increments the decay process based on the current turn count and decay timeline.

The method checks whether the turn count has reached the threshold to apply the next stage of decay as defined in the decay timeline. It updates the decay interval and index accordingly.

def apply_turn(
	self,
	turn,
	timer: float = 0,
	a_to_play=None,
	check_validity: bool = True
) -> bool:
Applies a turn to the board, mutating the board.

A turn can be a direction or an iterable of directions. Actions can either be in the form of enums from game.enums.Action or the ints to which the Action enum is mapped.

If check_validity is enabled, apply_turn performs checks to ensure no errors. If check_validity is disabled, the turn is assumed to be valid and runs without additional checks.

Parameters:
turn (enums.Action or Iterable[enums.Actions] or Iterable[int]): The action(s) the player takes in sequence.
timer (float, optional): The timer associated with the turn. Defaults to 0.
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.
check_validity (bool, optional): Whether to perform checks for validity before applying the turn. Defaults to True.

Returns:
bool: True if the turn was applied successfully, False otherwise.

def check_turn_start(self, a_to_play=None):
Checks to see if an apple spawned on top of the player at the turn start.

Parameters:
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.

def apply_trap(self, a_to_play: bool = None, check_validity: bool = True) -> bool:
Deploys a trap for the current player.

Parameters:
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.
check_validity (bool, optional): Whether to check the validity of the trap action. Defaults to True.

Returns:
bool: True if the trap was applied successfully, False if the trap is invalid.

def increment_traps(self):
def resolve_square(
	self,
	x: int,
	y: int,
	a_to_play: bool = None,
	check_validity: bool = True
) -> bool:
Resolves the state of a square on the board that a player just moved onto. For internal use by board. This function resolves apples and interaction with traps when a player moves onto it.

Parameters: x (int): The x-coordinate of the square to resolve.
y (int): The y-coordinate of the square to resolve.
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.
check_validity (bool, optional): Whether to perform checks for validity before resolving the square. Defaults to True.

Returns:
bool: True if the square was resolved successfully, False otherwise.

def apply_move(
	self,
	action: game.enums.Action,
	sacrifice: int = None,
	a_to_play: bool = None,
	check_validity: bool = True
) -> bool:
Applies a move to the board, mutating the board.

A move should be in the form of a direction. Actions can either be in the form of enums from game.enums.Action or the ints to which the Action enum is mapped.

If check_validity is enabled, apply_move performs checks to ensure no errors. If check_validity is disabled, the move is assumed to be valid and runs without additional checks.

Parameters:
action (enums.Action): The action representing the direction to move.
sacrifice (int, optional): The amount of sacrifice applied to the move. Defaults to None.
a_to_play (bool, optional): The player whose turn it is. If not provided, the current player is used.
check_validity (bool, optional): Whether to perform checks for validity before applying the move. Defaults to True.

Returns:
bool: True if the move was applied successfully, False otherwise.

def next_turn(self):
Advances the board to the next turn, recording and managing necessary game metadata.

def spawn_apples(self):
Spawns in apples on the current round.

def get_history(self) -> dict:
Get a dictionary representation for the renderer.

Returns:
dict: A dictionary representing the game history.

def get_map_generated(self) -> str:
Gets the map that is played on (including apple spawns).

Returns:
str: A string representation of the generated map.

def get_copy(self, build_history: bool = False) -> Board:
Returns a deep copy of the board.

Parameters:
build_history (bool, optional): Whether to include the history of the game in the copy. Defaults to False.

Returns:
Board: A deep copy of the current board object.

def forecast_trap(self, check_validity: bool = True) -> tuple:
Non-mutating version of apply_trap. Returns a tuple with the new board copy, then whether the trap was deployed successfully.

Parameters:
check_validity (bool, optional): Whether to validate the trap. Defaults to True.

Returns:
tuple: A tuple containing:
- Board: A copy of the board after the move. - bool: True if the trap was successful, False otherwise.

def forecast_move(
	self,
	move: game.enums.Action,
	sacrifice: int = None,
	check_validity: bool = True
) -> tuple:
Non-mutating version of apply_move. Returns a tuple with the new board copy, then whether the move executed properly.

Parameters: move (enums.Action): The action to apply (direction of movement). sacrifice (int, optional): The amount of sacrifice to apply. Defaults to None. check_validity (bool, optional): Whether to validate the move. Defaults to True.

Returns:
tuple: A tuple containing:
- Board: A copy of the board after the move.
- bool: True if the move was applied successfully, False otherwise.

def forecast_turn(self, turn, check_validity: bool = True) -> tuple:
Non-mutating version of apply_turn. Returns a tuple with the new board copy, then whether the turn executed properly.

Parameters:
turn (enums.Action or Iterable[enums.Actions] or Iterable[int]): The action(s) the player takes in sequence.
check_validity (bool, optional): Whether to validate the turn. Defaults to True.

Returns:
tuple: A tuple containing:
- Board: A copy of the board after the turn.
- bool: True if the turn was applied successfully, False otherwise.

def get_board_string(self) -> str:
Returns a string representation of the current state of the board, including player positions, apples, and traps. Mostly for internal use by developers.

Player positions (A for snake A's head, a for snake A's body, B for snake B's head, b for snake B's body, and x for walls)
Apple positions (. for apples)
Trap positions (a for traps belonging to snake A, b for traps belonging to snake B)
Returns:
tuple: A tuple containing:
- player_map (str): String representation of player positions.
- apple_map (str): String representation of apple positions.
- trap_map (str): String representation of trap positions.
- snake_a_length (int): Length of snake A.
- snake_b_length (int): Length of snake B.

game.enums
class Result(enum.IntEnum):
An enumeration.

PLAYER_A = <Result.PLAYER_A: 0>
PLAYER_B = <Result.PLAYER_B: 1>
TIE = <Result.TIE: 2>
ERROR = <Result.ERROR: 3>
Inherited Members
enum.Enum namevalue
builtins.int conjugatebit_lengthbit_countto_bytesfrom_bytesas_integer_ratiorealimagnumeratordenominator
class Action(enum.IntEnum):
An enumeration.

NORTH = <Action.NORTH: 0>
NORTHEAST = <Action.NORTHEAST: 1>
EAST = <Action.EAST: 2>
SOUTHEAST = <Action.SOUTHEAST: 3>
SOUTH = <Action.SOUTH: 4>
SOUTHWEST = <Action.SOUTHWEST: 5>
WEST = <Action.WEST: 6>
NORTHWEST = <Action.NORTHWEST: 7>
TRAP = <Action.TRAP: 8>
FF = <Action.FF: 9>
Inherited Members
enum.Enum namevalue
builtins.int conjugatebit_lengthbit_countto_bytesfrom_bytesas_integer_ratiorealimagnumeratordenominator
class Cell(enum.IntEnum):
An enumeration.

SPACE = <Cell.SPACE: 0>
WALL = <Cell.WALL: 1>
APPLE = <Cell.APPLE: 2>
PLAYER_HEAD = <Cell.PLAYER_HEAD: 3>
PLAYER_BODY = <Cell.PLAYER_BODY: 4>
ENEMY_HEAD = <Cell.ENEMY_HEAD: 5>
ENEMY_BODY = <Cell.ENEMY_BODY: 6>
Inherited Members
enum.Enum namevalue
builtins.int conjugatebit_lengthbit_countto_bytesfrom_bytesas_integer_ratiorealimagnumeratordenominator

game.player_board
class PlayerBoard:
A wrapper around the Board class to be able to call board and snake functions from the player's perspective.

Any coordinates should be given to the board in the form of x, y. Game objects are displayed, indexed, and stored on the board arrays as arr[y, x] for geometrical accuracy. Mask functions return arrays that should be indexed by [y, x].

Check_validity is on by default for most functions, but slows down execution. If a player is confident their actions are valid, they can directly apply turns and moves with check_validity as false.

Be wary that invalid actions/turns/function calls could lead to functions throwing errors, so make sure to handle them with a try/except in case so that your program doesn't crash. If an apply function throws an error, it is not guarenteed that the board state will be valid or that the state will be the same as when the function started.

PlayerBoard(is_player_a: bool, game_board: game.board.Board)
Parameters:
is_player_a (bool): If True, the player is player A; if False, the player is player B. game_board (Board): The game board object that holds the state of the current match.

game_board
is_player_a
player_snake
enemy_snake
player_cells
enemy_cells
player_trap_cells
enemy_trap_cells
def get_dim_x(self) -> int:
Returns the x dimension of the board.

Returns:
(int): Width of the board.

def get_dim_y(self) -> int:
Returns the y dimension of the board.

Returns:
(int): Height of the board.

def get_direction(self, enemy: bool = False) -> game.enums.Action:
Returns the direction of the snake

Parameters:
enemy (bool, optional): If True, returns the direction of the enemy snake. Defaults to False (for the current player).

Returns:
Action: The direction of the snake.

def is_valid_bid(self, bid: int) -> bool:
Checks if a bid is valid.

Parameters:
bid (int): The bid amount to check.

Returns:
bool: True if the bid is valid, False otherwise.

def apply_bid(self, my_bid: int, enemy_bid: int):
Applies the bids to each snake.

Parameters:
my_bid (int): The bid made by the player.
enemy_bid (int): The bid made by the enemy.

def forecast_bid(self, my_bid: int, enemy_bid: int) -> PlayerBoard:
Forecasts the result of a bid and predicts the new state of the game.

Parameters:
my_bid (int): The bid made by the player.
enemy_bid (int): The bid made by the enemy.

Returns:
PlayerBoard: A copy of the game with the game state after the bids.

def is_game_over(self) -> bool:
Checks if the game is over by determining if there is a winner.

Returns:
bool: True if the game is over, False otherwise.

def get_min_player_size(self) -> int:
Gets the minimum size below which a player cannot go.

Returns:
int: The minimum player size.

def get_current_apples(self) -> numpy.ndarray:
Returns an apple x 2 numpy array of apple coordinates currently on the board in (x, y) format.

Returns:
numpy.ndarray: A 2D array with each row representing the coordinates of an apple in (x, y) format.

def get_future_apples(self) -> list:
Returns a list of 3-integer tuples representing the future apples on the board, where each tuple is in the format (spawn time, x, y).

Returns:
list: A list of tuples, each containing the (time, x, y) coordinates for each future apple.

def get_head_location(self, enemy: bool = False) -> numpy.ndarray:
Returns the head location of the snake's head in the form of (x, y).

Parameters:
enemy (bool, optional): If True, returns the head location of the enemy's snake. Defaults to False, which returns the player's snake head location.

Returns:
numpy.ndarray: The (x, y) coordinates of the snake's head.

def get_tail_location(self, enemy: bool = False) -> numpy.ndarray:
Returns the tail location of the snake in the form of (x, y).

Parameters:
enemy (bool, optional): If True, returns the tail location of the enemy's snake. Defaults to False, which returns the player's snake tail location.

Returns:
numpy.ndarray: The (x, y) coordinates of the snake's tail.

def get_head_cells(self, num_cells: int, enemy=False) -> numpy.ndarray:
Retrieves num_cells physically occupied positions from the head of the snake.

Parameters:
num_cells (int): The number of physically occupied cells from the head of the snake.
enemy (bool, optional): If True, get the positions of the enemy snake's head; otherwise, for the player's snake.

Returns:
numpy.ndarray: A numpy array containing the positions of the head and the following cells of the snake.

def get_tail_cells(self, num_cells: int, enemy=False) -> numpy.ndarray:
Retrieves num_cells physically occupied positions from the tail of the snake.

Parameters:
num_cells (int): The number of positions to retrieve from the tail of the snake.
enemy (bool, optional): If True, get the positions of the enemy snake's tail; otherwise, for the player's snake.

Returns:
numpy.ndarray: A numpy array containing the positions of the tail and the preceding cells of the snake.

def get_all_locations(self, enemy: bool = False) -> numpy.ndarray:
Returns all physically occupied locations of either the player's or the opponent's snake.

Parameters:
enemy (bool, optional): If True, returns the locations of the enemy's snake. Defaults to False, which returns the player's snake locations.

Returns:
numpy.ndarray: A numpy array of length * 2 representing all locations of the snake as (x, y).

def get_length(self, enemy: bool = False) -> int:
Returns length of a snake

Parameters:
enemy (bool, optional): If True, returns the length of the enemy's snake. Defaults to False, which returns the player's snake length

Returns:
int: The length of the snake.

def get_unqueued_length(self, enemy: bool = False) -> int:
Returns the number of squares a snake physically occupies

Parameters:
enemy (bool, optional): If True, returns the length of the enemy's snake. Defaults to False, which returns the player's snake length

Returns:
int: Unqueued length of the snake.

def get_queued_length(self, enemy: bool = False) -> int:
Returns the amount of length a snake will accrue due to apples.

Parameters:
enemy (bool, optional): If True, returns the length of the enemy's snake. Defaults to False, which returns the player's snake length

Returns:
int: Queued length of the snake.

def get_am_player_a(self, enemy: bool = False) -> bool:
Returns if the calling player is player A or player B.

Parameters:
enemy (bool, optional): If True, checks if the current player is the enemy. Defaults to False, which checks for player A.

Returns:
bool: True if the calling player is player A, False if the calling player is player B.

def get_time_left(self, enemy: bool = False) -> float:
Returns the time left on the clock for a player.

Parameters:
enemy (bool, optional): If True, returns the time left for the opponent. Defaults to False, which returns the time left for the calling player.

Returns:
float: The time left on the clock for the specified player.

def is_possible_direction(self, action: game.enums.Action, enemy: bool = False) -> bool:
Checks directions to move in given snake's current direction it is facing, not accounting for board bounds or cell occupancy.

Parameters:
action (enums.Action): The direction to check.
enemy (bool, optional): If True, checks for the opponent's snake. Defaults to False, which checks for the player's snake.

Returns:
bool: True if the direction is valid for the given snake, False otherwise.

def is_possible_move(
	self,
	move: game.enums.Action,
	sacrifice: int = None,
	enemy: bool = False
) -> bool:
Checks if the snake can make a move based on the specified action, sacrifice, and direction, accounting for board bound. Does not account for cell occupancy or length changes. from traps.

Parameters:
move (enums.Action): The direction to move (e.g., Action.NORTH, Action.SOUTH).
sacrifice (int, optional): The sacrifice value to check. If not provided, the current sacrifice value is used.
enemy (bool, optional): If True, checks for the opponent's snake. Defaults to False, which checks for the player's snake.

Returns:
bool: True if the snake can make the move based on the specified conditions, False otherwise.

def is_valid_action(self, action: game.enums.Action, enemy: bool = False) -> bool:
Checks if the given action is valid for a player.

Parameters:
action (enums.Action): The action to validate (e.g., Action.NORTH, Action.SOUTH).
enemy (bool, optional): If True, checks the validity for the opponent. Defaults to False.

Returns:
bool: True if the action is valid for the player, False otherwise.

def is_valid_move(
	self,
	move: game.enums.Action,
	sacrifice: int = None,
	enemy: bool = False
) -> bool:
Checks if the given move is valid for the current player, accounting for the direction, sacrifice, and enemy.

Parameters:
move (enums.Action): The move to validate.
sacrifice (int, optional): The amount of sacrifice to apply. If not provided, the current sacrifice value is used.
enemy (bool, optional): If True, checks the validity for the opponent. Defaults to False.

Returns:
bool: True if the move is valid for the player, False otherwise.

def is_valid_trap(self, enemy: bool = False) -> bool:
Returns whether the player can deploy a trap.

Parameters:
enemy (bool, optional): If True, checks the validity for the opponent. Defaults to False.

Returns:
bool: True if the player can apply a trap, False otherwise.

def is_valid_turn(self, turn, enemy: bool = False) -> bool:
Returns if the given turn is a valid turn. A turn can be an Action or iterable of Actions. Actions can either be in the form of enums given in game.enums.Action or the ints to which the Action enum is mapped.

Parameters:
turn (enums.Action or Iterable[enums.Actions] or Iterable[int]): The action(s) the player takes in sequence.
enemy (bool, optional): If True, checks the validity for the opponent. Defaults to False.

Returns:
bool: True if the turn is valid, False otherwise.

def get_loc_after_move(self, action: game.enums.Action, enemy: bool = False) -> numpy.ndarray:
Simulates the location of the snake's head after the given action is applied.

Parameters:
action (enums.Action): The action to simulate (e.g., Action.NORTH, Action.SOUTH).
enemy (bool, optional): If True, simulates the opponent's snake's head movement. Defaults to False, simulating the player's snake's head movement.

Returns:
numpy.ndarray: The simulated location of the snake's head after the move.

def get_possible_directions(self, enemy: bool = False) -> list:
Retrieves the possible directions the snake can move in, without considering the board state or cell occupancy.

Parameters:
enemy (bool, optional): If True, retrieves the possible directions for the opponent's snake. Defaults to False, retrieving for the player's snake.

Returns:
list: A list of valid directions (as Action enum values) that the snake can move in.

def get_apples_eaten(self, enemy: bool = False) -> int:
Retrieves the number of apples eaten by the snake.

Parameters:
enemy (bool, optional): If True, retrieves the number of apples eaten by the opponent's snake. Defaults to False, retrieving for the player's snake.

Returns:
int: The number of apples eaten by the snake.

def cell_in_bounds(self, loc: tuple | numpy.ndarray) -> bool:
Checks if the given location is within the bounds of the board.

Parameters:
loc (tuple or numpy.ndarray): The coordinates to check, represented as (x, y).

Returns:
bool: True if the location is within bounds, False otherwise.

def cell_in_bounds_xy(self, x: int, y: int) -> bool:
Checks if the given location is within the bounds of the board.

Parameters:
x (int): x coordinate to check
y (int): y coordinate to check

Returns:
bool: True if the location is within bounds, False otherwise.

def try_move(
	self,
	action: game.enums.Action,
	sacrifice: int = None,
	enemy: bool = False
) -> bool:
Returns the tail cells that would be los in the event of a move as well as the new head location.

Parameters:
action (enums.Action): The action representing the move to be made (e.g., Action.NORTH, Action.SOUTH).
sacrifice (int, optional): The amount of sacrifice to apply. If not provided, the current sacrifice value is used.
enemy (bool, optional): If True, applies the move for the enemy. Defaults to False (for the current player).

Returns:
tuple: A tuple containing: - numpy.ndarray: The new location of the snake's head. - list: The cells that would be lost from the tail if the move is applied.

def try_trap(self, enemy: bool = False) -> numpy.ndarray:
Returns the cell at the tail of the snake, which would represent the trap.

Parameters:
enemy (bool, optional): If True, applies the trap for the enemy. Defaults to False (for the current player).

Returns:
numpy.ndarray: The cell at the tail of the snake, which would represent the trap.

def try_action(self, action: game.enums.Action, enemy: bool = False) -> numpy.ndarray:
Returns changes to the snake that would occur if an action performed.

Parameters:
action (enums.Action): The action to perform (e.g., Action.TRAP, Action.MOVE).
enemy (bool, optional): If True, performs the action for the enemy. Defaults to False (for the current player).

Returns:
numpy.ndarray: The resulting cell after performing the action (either the trap or the new position after move).

def try_sacrifice(self, sacrifice: int = None, enemy: bool = False) -> list:
Tries to apply a sacrifice (removal of cells from the snake's tail) for the player or the enemy.

Parameters:
sacrifice (int, optional): The amount of sacrifice. If not provided, the current sacrifice value is used.
enemy (bool, optional): If True, applies the sacrifice for the enemy. Defaults to False (for the current player).

Returns:
list: A list of cells that would be removed from the tail of the snake if the sacrifice is applied.

def apply_sacrifice(self, sacrifice: int = None, enemy: bool = False) -> list:
Applies a sacrifice (removal of cells from the snake's tail) for the player or the enemy.

Parameters:
sacrifice (int, optional): The amount of sacrifice to apply. If not provided, the current sacrifice value is used.
enemy (bool, optional): If True, applies the sacrifice for the enemy. Defaults to False (for the current player).

Returns:
list: A list of cells that are removed from the tail of the snake after the sacrifice is applied.

def apply_action(self, action: game.enums.Action, check_validity: bool = True) -> bool:
Performs an action, mutating the board.

Parameters:
action (enums.Action): The action to perform (e.g., Action.TRAP, Action.MOVE).
enemy (bool, optional): If True, performs the action for the enemy. Defaults to False (for the current player).

Returns:
bool: If the action succeeded or not.

def apply_trap(self, check_validity: bool = True) -> bool:
Deploys a trap for the current player, mutating the board.

Parameters:
check_validity (bool, optional): Whether to check the validity of the trap action. Defaults to True.

Returns:
bool: True if the trap was applied successfully, False if the trap is invalid.

def apply_move(
	self,
	move: game.enums.Action,
	sacrifice: int = None,
	check_validity: bool = True
) -> bool:
Applies a move to the board, mutating the board.

A move should be in the form of a direction. Actions can either be in the form of enums from game.enums.Action or the ints to which the Action enum is mapped.

If check_validity is enabled, apply_move performs checks to ensure no errors. If check_validity is disabled, the move is assumed to be valid and runs without additional checks.

Parameters:
move (enums.Action): The action representing the direction to move.
sacrifice (int, optional): The amount of sacrifice applied to the move. Defaults to None.
check_validity (bool, optional): Whether to perform checks for validity before applying the move. Defaults to True.

Returns:
bool: True if the move was applied successfully, False otherwise.

def apply_turn(self, turn, check_validity: bool = True, reverse: bool = False) -> bool:
Applies a turn to the board, mutating the board, ending the current turn, and passing the move to the next player.

A turn can be a direction or an iterable of directions. Actions can either be in the form of enums from game.enums.Action or the ints to which the Action enum is mapped.

If check_validity is enabled, apply_turn performs checks to ensure no errors. If check_validity is disabled, the turn is assumed to be valid and runs without additional checks.

Parameters:
turn (enums.Action or Iterable[enums.Actions] or Iterable[int]): The action(s) the player takes in sequence.
check_validity (bool, optional): Whether to perform checks for validity before applying the turn. Defaults to True.
reverse (bool, optional): Reverses the perspective the board is seen from following application of the turn. Defaults to False.

Returns:
bool: True if the turn was applied successfully, False otherwise.

def end_turn(self, reverse: bool = False):
Ends the current turn and optionally reverses the board state.

Parameters:
reverse (bool, optional): Whether to reverse the board state after ending the turn. Defaults to False.

def forecast_action(self, action: game.enums.Action, check_validity: bool = True) -> tuple:
Simulates the application of an action (move or trap) on a copy of the current board and returns the resulting board state.

Parameters:
action (enums.Action): The action to forecast (e.g., move or trap).
check_validity (bool, optional): Whether to check the validity of the action. Defaults to True.

Returns:
tuple: A tuple containing:
- The board state after applying the action (as a copy of the current board).
- A boolean indicating whether the action was successfully applied (True if successful, False if not).

def forecast_trap(self, check_validity: bool = True) -> tuple:
Simulates the application of a trap on a copy of the current board and returns the resulting board state.

Parameters:
check_validity (bool, optional): Whether to check the validity of the trap action. Defaults to True.

Returns:
tuple: A tuple containing:
- The board state after applying the trap (as a copy of the current board).
- A boolean indicating whether the trap was successfully applied (True if successful, False if not).

def forecast_move(
	self,
	move: game.enums.Action,
	sacrifice: int = None,
	check_validity: bool = False
) -> tuple:
Simulates the application of a move (with or without sacrifice) on a copy of the current board and returns the resulting board state.

Parameters:
move (enums.Action): The action representing the move to be made (e.g., Action.NORTH, Action.SOUTH).
sacrifice (int, optional): The amount of sacrifice to apply. Defaults to None.
check_validity (bool, optional): Whether to check the validity of the move. Defaults to True.

Returns:
tuple: A tuple containing:
- The board state after applying the move (as a copy of the current board).
- A boolean indicating whether the move was successfully applied (True if successful, False if not).

def forecast_turn(self, turn, check_validity: bool = True, reverse: bool = False) -> tuple:
Simulates the application of a whole turn (multiple moves) on a copy of the current board and returns the resulting board state.

Parameters:
turn (enums.Action or Iterable[enums.Actions] or Iterable[int]): The action(s) the player takes in sequence.
check_validity (bool, optional): Whether to check the validity of each action in the turn. Defaults to True.
reverse (bool, optional): reverses the perspective the board is seen from following application of the turn. Defaults to False.

Returns:
tuple: A tuple containing:
- The board state after applying the turn (as a copy of the current board).
- A boolean indicating whether the turn was successfully applied (True if successful, False if not).

def reverse_perspective(self):
Reverses the perspective the board is seen from.

def is_my_turn(self) -> bool:
Returns whether it is the player's turn or not.

Returns:
bool: True if it's the player's turn, False otherwise.

def is_enemy_turn(self) -> bool:
Returns whether it is the enemy's turn or not.

Returns:
bool: True if it's the enemy's turn, False otherwise.

def get_copy(self) -> PlayerBoard:
Returns a copy of this board.

Returns:
PlayerBoard: A new instance of PlayerBoard representing a copy of the current board.

def is_occupied(self, x: int, y: int) -> bool:
Returns whether the cell at (x, y) is occupied or not.

Parameters:
x (int): The x-coordinate of the cell to check.
y (int): The y-coordinate of the cell to check.

Returns:
bool: True if the cell is occupied, False otherwise.

def get_my_trap_life(self, x: int, y: int) -> int:
Returns the remaining life of the player's trap at the specified coordinates.

Parameters:
x (int): The x-coordinate of the trap.
y (int): The y-coordinate of the trap.

Returns:
int: The remaining life of the player's trap at the given coordinates.

def get_enemy_trap_life(self, x: int, y: int) -> int:
Returns the remaining life of the enemy's trap at the specified coordinates.

Parameters:
x (int): The x-coordinate of the trap.
y (int): The y-coordinate of the trap.

Returns:
int: The remaining life of the enemy's trap at the given coordinates.

def has_my_trap(self, x: int, y: int) -> bool:
Checks if the player has a trap at the specified coordinates.

Parameters:
x (int): The x-coordinate to check for a player's trap.
y (int): The y-coordinate to check for a player's trap.

Returns:
bool: True if the player has a trap at the given coordinates, False otherwise.

def has_enemy_trap(self, x: int, y: int) -> bool:
Checks if the enemy has a trap at the specified coordinates.

Parameters:
x (int): The x-coordinate to check for the enemy's trap.
y (int): The y-coordinate to check for the enemy's trap.

Returns:
bool: True if the enemy has a trap at the given coordinates, False otherwise.

def has_apple(self, x: int, y: int) -> bool:
Returns whether the specified cell contains an apple.

Parameters:
x (int): The x-coordinate of the cell to check.
y (int): The y-coordinate of the cell to check.

Returns:
bool: True if the cell contains an apple, False otherwise.

def get_snake_mask(self, my_snake: bool = True, enemy_snake: bool = False) -> numpy.ndarray:
Returns a map-sized array with cells occupied by the player's snake and/or the enemy's snake as specified in arguments. Players' snakes' heads and bodies are denoted by their relevant enums.Cell enum values.

Parameters:
my_snake (bool, optional): If True, includes the player's snake. Defaults to True.
enemy_snake (bool, optional): If True, includes the enemy's snake. Defaults to False.

Returns:
numpy.ndarray: A 2D numpy array with the snake's body and head marked according to the enums.

def get_trap_mask(self, my_traps: bool = True, enemy_traps: bool = False) -> numpy.ndarray:
Returns a mask representing the lifetime of traps for the player and the enemy. Positive values represent the player's trap lifetime, and negative values represent the enemy's trap lifetime.

Parameters:
my_traps (bool, optional): If True, includes the player's traps. Defaults to True.
enemy_traps (bool, optional): If True, includes the enemy's traps. Defaults to False.

Returns:
numpy.ndarray: A 2D numpy array where positive values correspond to the player's trap lifetime and negative values correspond to the enemy's trap lifetime.

def get_trap_mask_enemy(self, my_traps: bool = False, enemy_traps: bool = True) -> numpy.ndarray:
Returns a mask representing the lifetime of enemy traps and the player's traps. Positive values represent the enemy's trap lifetime, and negative values represent the player's trap lifetime.

Parameters:
my_traps (bool, optional): If True, includes the player's traps. Defaults to False.
enemy_traps (bool, optional): If True, includes the enemy's traps. Defaults to True.

Returns:
numpy.ndarray: A 2D numpy array where positive values correspond to the enemy's trap lifetime and negative values correspond to the player's trap lifetime.

def get_wall_mask(self) -> numpy.ndarray:
Returns a map-sized array with only walls, represented by their enum (1).

Returns: numpy.ndarray: A 2D numpy array where cells containing walls are represented by the enum value (1).

def get_portal_mask(self, descriptive: bool = False) -> numpy.ndarray:
Returns a map-sized array with portals. If descriptive is marked as True, returns non-portal locations as (-1, -1) and portal locations in the form of a 2-dim coordinate in the form (destination_x, destination_y) at mask[y, x]. Otherwise, returns 0/1 mask of if coordinates are portals or not.

Parameters:
descriptive (bool, optional): If True, the function will return a detailed mask with portal coordinates (destination_x, destination_y) for portal locations and -1 for non-portal locations. If False, it returns a binary mask where 1 indicates portal locations and 0 indicates non-portal locations. Default is False.

Returns:
numpy.ndarray: A numpy array of the same size as the map, where each entry corresponds to the portal at that location on the map.

def get_portal_dest(self, x: int, y: int) -> numpy.ndarray:
Returns the destination portal of the source portal given by coordinates (x, y) on the game board.

Parameters:
x (int): The x-coordinate of the portal.
y (int): The y-coordinate of the portal.

Returns:
np.ndarray: The portal destination at the specified portal (x, y) on the game board. Returns (-1, -1) for an invalid cell. The value represents the destination of the portal in the form of (x, y) coordinates.

def is_portal(self, x: int, y: int) -> bool:
Checks whether the given coordinates (x, y) represent a portal on the game board.

Parameters:
x (int): The x-coordinate on the game board.
y (int): The y-coordinate on the game board.

Returns:
bool: True if the coordinates (x, y) represent a portal, False otherwise.

def get_portal_dict(self) -> dict:
Returns a dictionary mapping pairs of portals together (each) pair of portals appears twice in this dict, each one once as the key tuple and once as the value tuple.

Returns:
dict: A dictionary where the keys and values are tuples representing the coordinates of the portals and their respective destination coordinates.

def get_apple_mask(self) -> numpy.ndarray:
Returns a map-sized array with only apples, represented by their enum (2).

Returns:
numpy.ndarray: A 2D numpy array where cells containing apples are represented by the enum value (2).

def get_turn_count(self) -> int:
Returns the current turn count of the game.

Returns:
int: The current number of turns that have passed in the game.

def get_traps_until_limit(self, enemy: bool = False) -> int:
Returns the number of traps the player can still deploy on this turn until they reach the limiting number of traps.

Parameters:
enemy (bool): If True, the function returns the number of traps remaining for the enemy. If False, it returns the number of traps remaining for the player. Default is False.

Returns:
int: The number of remaining traps the player (or enemy, if enemy is True) can still play until they reach the trap limit for the turn.

def get_traps_placed(self, enemy: bool = False) -> int:
Returns the number of traps that have been placed on this turn by the player (or enemy, if enemy is True.

Parameters:
enemy (bool): If True, the function returns the number of traps placed by the enemy. If False, it returns the number of traps placed by the player. Default is False.

Returns:
int: The number of traps placed by the player or the enemy this turn.

def get_traps_limit(self, enemy: bool = False) -> int:
Returns the maximum number of traps that the player (or enemy, if enemy is True) can place on a turn.

Parameters:
enemy (bool): If True, the function returns the maximum number of traps the enemy can place. If False, it returns the maximum number of traps the player can place. Default is False.

Returns:
int: The maximum number of traps the player or the enemy can place this turn.

def get_max_length(self, enemy: bool = False) -> int:
Returns the maximum length the player (or enemy, if enemy is True) has achieved this game.

Parameters:
enemy (bool): If True, the function returns the maximum length for the enemy. If False, it returns the maximum length for the player. Default is False.

Returns:
int: The maximum length the player or the enemy has achieved has achieved this game.

def cell_occupied_by(self, x: int, y: int) -> game.enums.Cell:
Returns the relevant enum for what a cell is currently occupied by (excluding apples).

Parameters:
x (int): The x-coordinate of the cell.
y (int): The y-coordinate of the cell.

Returns:
enums.Cell: The enum representing what occupies the cell (e.g., WALL, PLAYER_HEAD, PLAYER_BODY, SPACE).

def currently_decaying(self) -> bool:
Returns whether snakes will decay at the beginning of this turn.

Returns:
bool: If snakes will decay at the beginning of this turn.

def get_current_decay_interval(self) -> int:
Returns the current decay interval from the game board. Returns -1 if decays have not begun yet.

Returns:
int: The current decay interval value.

def get_future_decay_intervals(self) -> list:
Returns a list of future decay intervals from the decay timeline.

Returns:
list: A list of tuples representing future decay intervals in (start turn, interval) format.

def get_next_decay_interval(self) -> tuple:
Returns a the next decay interval after the current one. Returns the current one if current is already the last decay interval.

Returns:
tuple: Tuple representing next decay interval in (start turn, interval) format.

def get_next_decay_event(self) -> int:
Returns the turns until thse next decay event.

Returns:
int: Returns the number of turns until the next turn that snakes will start decaying at.



game.snake
class Snake:
This class represents a snake. It is built as a wrapper around the numpy-vectorized queue game.game_queue.

Snake(min_player_size: int = 2, copy: bool = False)
Initializes the Snake object with the minimum player size and copy flag.

Parameters:
min_player_size (int, optional): The minimum size of the snake. Defaults to 2.
copy (bool, optional): Whether to initialize the snake as a copy. Defaults to False.

min_player_size
def get_max_traps(self) -> int:
Returns the maximum number of traps that can be placed based on the maximum length of the snake.

Returns:
int: The maximum number of traps that can be placed. This value is determined by dividing the maximum length achieved by 2.

def start(self, start_loc: numpy.ndarray, start_size: int):
Initializes the snake to the starting position and size.

Parameters:
start_loc (numpy.ndarray): A NumPy array representing the starting location of the snake. start_size (int): The initial size of the snake.

def get_lengthen_coef(self) -> int:
Returns the coefficient by which the snake lengthens when it eats an apple.

Returns:
int: The amount by which the snake lengthens when it eats an apple.

def increment_sacrifice(self):
Increments the sacrifice necessary for a move by 2.

def reset(self):
Resets the sacrifice for a move to 1.

def get_head_loc(self) -> numpy.ndarray:
Retrieves the location of the head of the snake as a (x, y) coordinate.

Returns:
numpy.ndarray: A numpy array representing the location of the head of the snake.

def get_tail_loc(self) -> numpy.ndarray:
Retrieves the location of the tail of the snake as a (x, y) coordinate.

Returns:
numpy.ndarray: A numpy array representing the location of the tail of the snake.

def get_all_loc(self) -> numpy.ndarray:
Retrieves the locations of all parts of the snake as an array of (x, y) coordinates.

Returns:
numpy.ndarray: A numpy array containing the locations of all parts of the snake.

def get_direction(self) -> game.enums.Action:
Retrieves the current direction of the snake.

Returns:
Action: An Action enum value representing the current direction of the snake (e.g., Action.NORTH, Action.SOUTH).

def get_unqueued_length(self) -> int:
Retrieves the current physical length of the snake (discounts queued length)

Returns:
int: The physical length of the snake

def get_length(self) -> int:
Retrieves the current total length of the snake, including any pending length from apples eaten.

Returns:
int: The total length of the snake, including any length gained from eating apples.

def get_next_loc(self, action: game.enums.Action, head_loc=None) -> numpy.ndarray:
Simulates the location of the snake's head if the given action is taken.

Parameters:
action (enums.Action): The action to simulate (e.g., Action.NORTH, Action.SOUTH).
head_loc (numpy.ndarray, optional): The current location of the snake's head to simulate the movement from. If not provided, the current head location is used.

Returns:
- numpy.ndarray: The simulated location of the snake's head after taking the action.

def is_valid_bid(self, bid: int) -> bool:
Checks if a bid is valid for the snake based on its current length.

Parameters:
bid (int): The bid to be validated.

Returns:
bool: True if the bid is valid (i.e., the snake's length minus the bid is greater than or equal to the minimum player size), otherwise False.

def is_valid_trap(
	self,
	length: int = None,
	unqueued: int = None,
	traps_placed: int = None,
	max_traps: int = None
) -> bool:
Checks if the snake can trap based on length and unqueued length.

Parameters:
length (int, optional): The current length of the snake. If not provided, the current length is used.
unqueued (int, optional): The unqueued length of the snake. If not provided, the current unqueued length is used.

Returns:
bool: True if the snake can trap (i.e., unqueued length is greater than 1 and total length is greater than the minimum player size), otherwise False.

def is_valid_direction(
	self,
	action: game.enums.Action,
	direction: game.enums.Action = None
) -> bool:
Checks if a given action is a valid direction based on the current direction of the snake.

Parameters:
action (enums.Action): The action to be validated (e.g., Action.NORTH, Action.SOUTH).
direction (enums.Action, optional): The current direction of the snake. If not provided, the current direction is used.

Returns:
bool: True if the action is a valid direction to move (i.e., not opposite or invalid relative to the current direction), otherwise False.

def is_valid_sacrifice(self, sacrifice: int = None, length: int = None) -> bool:
Checks if the snake can perform a sacrifice based on its length and the specified sacrifice value.

Parameters:
sacrifice (int, optional): The value representing the sacrifice. If not provided, it defaults to None.
length (int, optional): The current length of the snake. If not provided, the current length is used.

Returns:
bool: If the sacrifice is valid.

def can_move(
	self,
	action: game.enums.Action,
	sacrifice: int = None,
	direction: game.enums.Action = None,
	length: int = None
) -> bool:
Checks if the snake can make a move based on the specified action, sacrifice, and direction.

Parameters:
action (enums.Action): The action representing the move to be made (e.g., Action.NORTH, Action.SOUTH).
sacrifice (int, optional): The sacrifice value to check. If not provided, the current sacrifice value is used.
direction (enums.Action, optional): The current direction of the snake. If not provided, the current direction is used.
length (int, optional): The current length of the snake. If not provided, the current length is used.

Returns:
bool: True if the move is valid (i.e., the sacrifice is within acceptable limits, and the direction is not invalid), otherwise False.

def get_valid_directions(self, direction: game.enums.Action = None) -> list:
Retrieves the possible directions the snake can move in, without considering the board state.

Parameters:
direction (Action, optional): The current direction of the snake. If not provided, the current direction is used.

Returns:
list: A list of valid directions (as Action enum values) that the snake can move in.

def eat_apple(self):
Simulate eating an apple, queuing length and modifying max length achieved as necessary.

def get_apples_eaten(self) -> int:
Retrieves the total number of apples the snake has eaten.

Returns:
int: The total number of apples eaten by the snake.

def apply_bid(self, bid: int):
Decreases the snake's length by the specified bid amount for the first turn.

Parameters:
bid (int): The amount by which the snake's length will be decreased.

def get_last_cells(self, num_cells: int = 1) -> numpy.ndarray:
Retrieves the last num_cells cells from the tail side of the snake.

Parameters:
num_cells (int, optional): The number of tail-side cells to retrieve. Defaults to 1.

Returns:
numpy.ndarray: a numpy array representing the last cells of the snake as num_cells (x, y)

def get_first_cells(self, num_cells: int = 1) -> numpy.ndarray:
Retrieves the first num_cells cells from the head side of the snake.

Parameters:
num_cells (int, optional): The number of head-side cells to retrieve. Defaults to 1.

Returns:
numpy.ndarray: a numpy array representing the first cells of a the snake as num_cells (x, y)

def try_sacrifice(self, sacrifice: int = None) -> numpy.ndarray:
Returns the cells that would be removed from the tail of the snake if a sacrifice is applied.

Parameters:
sacrifice (int, optional): The amount of sacrifice. If not provided, the current sacrifice value is used.

Returns:
numpy.ndarray: An array of cells that would be removed from the tail of the snake if the sacrifice is applied.

def apply_sacrifice(self, sacrifice: int = None) -> list:
Applies the sacrifice to the snake and returns the cells to be removed from the tail.

Parameters:
sacrifice (int, optional): The amount of sacrifice to apply. If not provided, the current sacrifice value is used.

Returns:
list: A list of cells that are removed from the tail of the snake after the sacrifice is applied.

def apply_head_move(self, action: game.enums.Action) -> numpy.ndarray:
Moves the head to the next location according to the action taken and updates the direction.

Parameters:
action (enums.Action): The action representing the direction in which the snake's head should move.

Returns:
numpy.ndarray: The new location of the snake's head after the move.

def try_trap(self) -> numpy.ndarray:
Returns the cell at the tail of the snake, which would represent the trap.

Returns:
numpy.ndarray: The cell at the tail of the snake.

def try_move(self, action: game.enums.Action, sacrifice: int = None) -> tuple:
Simulates the move and returns the tail cells that would be lost, as well as the new head location.

Parameters: action (enums.Action): The action representing the direction the snake will move.
sacrifice (int, optional): The amount of sacrifice. Defaults to the current sacrifice value if not provided.

Returns:
tuple: A tuple containing:
- numpy.ndarray: The new location of the snake's head.
- list: The cells that would be lost from the tail if the move is applied.

def push_trap(self) -> numpy.ndarray:
Removes and returns the cell at the tail of the snake, representing the trap created.

Returns:
numpy.ndarray: The cell at the tail of the snake.

def push_head_cell(self, loc: numpy.ndarray):
Enqueues the snake's new head location into the interanal queue.

Parameters:
loc (numpy.ndarray): The head location to enqueue.

def push_move(self, action: game.enums.Action, sacrifice: int = None) -> tuple:
Applies the move and returns the tail cells that would be lost, as well as the new head location. Does not enqueue the new location (could potentially require portal transformation).

Parameters:
action (enums.Action): The action representing the direction the snake will move.
sacrifice (int, optional): The amount of sacrifice. Defaults to the current sacrifice value if not provided.

Returns:
tuple: A tuple containing:
- numpy.ndarray: The new location of the snake's head.
- list: The cells that would be lost from the tail if the move is applied.

def get_copy(self) -> Snake:
Return a deep copy of the snake.

Returns:
Snake: A deep copy of the current snake object.